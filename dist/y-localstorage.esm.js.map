{"version":3,"file":"y-localstorage.esm.js","sources":["../src/y-localstorage.ts"],"sourcesContent":["import * as Y         from 'yjs'\nimport { Observable } from 'lib0/observable'\n\n//namespace LocalStorageProvider {\n  const GUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n\n  type SubDocChanges = {\n    added:Set<Y.Doc>, removed:Set<Y.Doc>, loaded:Set<Y.Doc>\n  }\n\n  export class LocalStorageProvider extends Observable<any> {\n    private _DocPrefix:string\n    private _sharedDoc:Y.Doc\n\n    private _UpdateCounter:number = 1    // index \"0\" is reserved for compaction\n    private _CounterLimit:number  = 5\n\n    private _pendingUpdates:number   = 0\n    private _completedUpdates:number = 0\n\n    private _SubDocMap:Map<Y.Doc,LocalStorageProvider> = new Map()\n\n    constructor (DocName:string, sharedDoc:Y.Doc, CounterLimit:number = 5) {\n    \tsuper()\n    \t\n      this._DocPrefix = DocName + '-'\n      this._sharedDoc = sharedDoc\n\n      this._UpdateCounter = 0        // will be updated by \"_applyStoredUpdates\"\n      this._CounterLimit  = CounterLimit\n\n      try {\n        this._applyStoredUpdates()         // also updates \"this._UpdateCounter\"\n      } catch (Signal:any) {\n        this._breakdownWith(\n          'could not restore document from persistence', Signal\n        )\n      }\n\n      this._storeUpdate = this._storeUpdate.bind(this)\n      sharedDoc.on('update', this._storeUpdate)\n\n      this._manageSubDocs = this._manageSubDocs.bind(this)\n      sharedDoc.on('subdocs', this._manageSubDocs)\n\n      this.destroy = this.destroy.bind(this)\n      sharedDoc.on('destroy', this.destroy)\n    }\n\n  /**** isSynced - is true while this provider and its sharedDoc are in-sync ****/\n\n    public get isSynced ():boolean {\n      return (this._pendingUpdates === 0)\n    }\n\n  /**** destroy - destroys persistence, invalidates provider ****/\n\n    public destroy ():void {\n      if (this._sharedDoc == null) { return }    // persistence no longer exists\n\n      this._removeStoredUpdatesStartingWith(0)\n      this._removeStoredSubDocs()\n\n      this._sharedDoc.off('update',  this._storeUpdate)\n      this._sharedDoc.off('subdocs', this._manageSubDocs)\n      this._sharedDoc.off('destroy', this.destroy)\n\n      if (! this.isSynced) {\n        this._pendingUpdates = 0\n        this.emit('sync-aborted',[this,1.0])\n      }\n\n// @ts-ignore allow clearing of \"this._sharedDoc\"\n      this._sharedDoc = undefined\n    }\n\n  /**** destroyPersistenceNamed ****/\n\n    public static destroyPersistenceNamed (DocName:string):void {\n      let KeyList:string[] = []\n        for (let i = 0, l = localStorage.length; i < l; i++) {\n          const Key = localStorage.key(i) as string\n          if (\n            Key.startsWith(DocName + '-') || Key.startsWith(DocName + '.')\n          ) { KeyList.push(Key) }\n        }\n      KeyList.forEach((Key) => {\n        localStorage.removeItem(Key)\n      })\n    }\n\n  /**** _applyStoredUpdates - applies all stored (incremental) updates to sharedDoc ****/\n\n    private _applyStoredUpdates ():void {\n      const PrefixLength = this._DocPrefix.length\n\n      const StorageKeys = this._StorageKeys()\n      if (StorageKeys.length > 0) {\n        this._pendingUpdates += StorageKeys.length; this._reportProgress()\n\n        StorageKeys.forEach((Key) => {\n          let UpdateIndex = parseInt(Key.slice(PrefixLength),10)\n          if (UpdateIndex > this._UpdateCounter) {\n            this._UpdateCounter = UpdateIndex\n          }\n\n          const Update = new Uint8Array(JSON.parse(localStorage.getItem(Key) as string))\n          Y.applyUpdate(this._sharedDoc, Update, this)\n                                          // updates can be applied in any order\n          this._completedUpdates++; this._reportProgress()\n        })\n      } else {\n        this._UpdateCounter = 1                // keep \"0\" for compacted updates\n        this._reportProgress()\n      }\n    }\n\n  /**** _storeUpdate - stores a given (incremental) update ****/\n\n    private _storeUpdate (Update:Uint8Array, Origin?:any):void {\n      if (this._sharedDoc == null) { return }    // persistence no longer exists\n\n      if (Origin !== this) {          // ignore updates applied by this provider\n        this._pendingUpdates++; this._reportProgress()\n          try {\n            if (this._UpdateCounter < this._CounterLimit) {     // append update\n              localStorage.setItem(                                  // may fail\n                this._DocPrefix + this._UpdateCounter,\n                JSON.stringify(Array.from(Update))\n              )\n\n              this._UpdateCounter++\n            } else {                     // compact previous and current updates\n              localStorage.setItem(                                  // may fail\n                this._DocPrefix + 0,\n                JSON.stringify(Array.from(Y.encodeStateAsUpdate(this._sharedDoc)))\n              )\n\n              this._removeStoredUpdatesStartingWith(1)\n            }\n          } catch (Signal:any) {\n            this._breakdownWith(\n              'could not persist document update', Signal\n            )\n          }\n        this._completedUpdates++; this._reportProgress()\n      }\n    }\n\n  /**** _removeStoredUpdatesStartingWith - removes stored (incremental) updates ****/\n\n    private _removeStoredUpdatesStartingWith (minimalIndex:number):void {\n      const PrefixLength = this._DocPrefix.length\n\n      let lastFailure:any = undefined\n        this._StorageKeys().forEach((Key) => {\n          let UpdateIndex = parseInt(Key.slice(PrefixLength),10)\n          if (UpdateIndex >= minimalIndex) {\n            try {\n              localStorage.removeItem(Key)                           // may fail\n            } catch (Signal:any) {\n              lastFailure = Signal\n            }\n          }\n        })\n      if (lastFailure != null) {\n        console.warn(\n          'y-localstorage: could not clean-up localstorage, reason: ' + lastFailure\n        )\n      }\n\n      this._UpdateCounter = minimalIndex\n    }\n\n  /**** _removeStoredSubDocs - removes any stored subdocs ****/\n\n    private _removeStoredSubDocs ():void {\n      this._removeStoredSubDoc()                      // avoids duplicating code\n    }\n\n  /**** _removeStoredSubDoc - removes a single stored subdoc ****/\n\n    private _removeStoredSubDoc (SubDoc?:Y.Doc):void {\n      let lastFailure:any = undefined\n        const StorageKeys = (\n          SubDoc == null\n          ? this._StorageSubKeys()\n          : this._StorageSubKeysFor(SubDoc)\n        )\n\n        StorageKeys.forEach((Key) => {\n          try {\n            localStorage.removeItem(Key)                             // may fail\n          } catch (Signal:any) {\n            lastFailure = Signal\n          }\n        })\n      if (lastFailure != null) {\n        console.warn(\n          'y-localstorage: could not clean-up localstorage, reason: ' + lastFailure\n        )\n      }\n    }\n\n  /**** _breakdown - breaks down this provider ****/\n\n    private _breakdown ():void {\n// @ts-ignore allow clearing of \"this._sharedDoc\"\n      this._sharedDoc = undefined\n\n      if (! this.isSynced) {\n        this._pendingUpdates = 0\n        this.emit('sync-aborted',[this,1.0])\n      }\n\n      this._SubDocMap.forEach((Provider) => Provider._breakdown())\n    }\n\n  /**** _breakdownWith - breaks down this provider after failure ****/\n\n    private _breakdownWith (Message:string, Reason?:any):never {\n      this._breakdown()\n\n      throw new Error(\n        Message + (Reason == null ? '' : ', reason: ' + Reason)\n      )\n    }\n\n  /**** _manageSubDocs - manages subdoc persistences ****/\n\n    private _manageSubDocs (Changes:SubDocChanges):void {\n      const providePersistenceFor = (SubDoc:Y.Doc) => {\n        if (\n          ! this._SubDocMap.has(SubDoc) &&\n          (this._sharedDoc.guid !== SubDoc.guid)     // \"doc copies\" are strange\n        ) {\n          const SubDocProvider = new LocalStorageProvider(\n            this._DocPrefix.slice(0,-1) + '.' + SubDoc.guid, SubDoc,\n            this._CounterLimit\n          )\n          this._SubDocMap.set(SubDoc,SubDocProvider)\n        }\n      }\n\n      const { added, removed, loaded } = Changes\n\n      if (removed != null) {\n        removed.forEach((SubDoc:Y.Doc) => {\n          const Provider = this._SubDocMap.get(SubDoc)\n          if (Provider != null) { Provider._breakdown() }\n\n          this._SubDocMap.delete(SubDoc)\n\n          if (\n            (this._sharedDoc != null) &&          // \"doc copies\" are strange...\n            (this._sharedDoc.guid !== SubDoc.guid) &&\n            Array.from(this._sharedDoc.getSubdocs().values()).every(\n              (existingSubDoc) => (existingSubDoc.guid !== SubDoc.guid)\n            )                                                       // ...really\n          ) {\n            this._removeStoredSubDoc(SubDoc)\n          }\n        })\n      }\n\n      if (loaded != null) {\n        loaded.forEach((SubDoc:Y.Doc) => {\n          providePersistenceFor(SubDoc)\n        })\n      }\n    }\n\n  /**** _reportProgress - emits events reporting synchronization progress ****/\n\n    private _reportProgress ():void {\n      switch (true) {\n        case (this._pendingUpdates === 0):\n          this._completedUpdates = 0\n          this.emit('synced',[this])\n          break\n        case (this._completedUpdates === 0):\n          this.emit('sync-started',[this,0.0])\n          break\n        case (this._completedUpdates === this._pendingUpdates):\n          this.emit('sync-finished',[this,1.0])\n          this._pendingUpdates = this._completedUpdates = 0\n          this.emit('synced',[this])\n          break\n        default:\n          const Progress = this._completedUpdates/this._pendingUpdates\n          this.emit('sync-continued',[this,Progress])\n      }\n    }\n\n  /**** _StorageKeys - lists all keys used for sharedDoc itself ****/\n\n    private _StorageKeys ():string[] {\n      return this._StorageSubKeysFor()                // avoids duplicating code\n    }\n\n  /**** _StorageSubKeys - lists all keys used for subdocs of sharedDoc ****/\n\n    private _StorageSubKeys ():string[] {\n      const DocPrefix    = this._DocPrefix.slice(0,-1) + '.'\n      const PrefixLength = DocPrefix.length\n\n      const Result:string[] = []\n        for (let i = 0, l = localStorage.length; i < l; i++) {\n          const Key = localStorage.key(i) as string\n          if (\n            Key.startsWith(DocPrefix) &&\n            (GUIDPattern.test(Key.slice(PrefixLength)) === true)\n          ) { Result.push(Key) }\n        }\n      return Result\n    }\n\n  /**** _StorageSubKeysFor - lists all keys used for a given subdoc ****/\n\n    private _StorageSubKeysFor (SubDoc?:Y.Doc):string[] {\n      const DocPrefix = (\n        SubDoc == null\n        ? this._DocPrefix\n        : this._DocPrefix.slice(0,-1) + '.' + SubDoc.guid + '-'\n      )\n      const PrefixLength = DocPrefix.length\n\n      const Result:string[] = []\n        for (let i = 0, l = localStorage.length; i < l; i++) {\n          const Key = localStorage.key(i) as string\n          if (\n            Key.startsWith(DocPrefix) &&\n            (/^\\d+$/.test(Key.slice(PrefixLength)) === true)\n          ) { Result.push(Key) }\n        }\n      return Result\n    }\n  }\n//}\n"],"names":["GUIDPattern","LocalStorageProvider","_Observable","DocName","sharedDoc","CounterLimit","_this","call","this","_DocPrefix","_sharedDoc","_UpdateCounter","_CounterLimit","_pendingUpdates","_completedUpdates","_SubDocMap","Map","_applyStoredUpdates","Signal","_breakdownWith","_storeUpdate","bind","on","_manageSubDocs","destroy","_proto","prototype","_createClass","_removeStoredUpdatesStartingWith","_removeStoredSubDocs","off","isSynced","emit","undefined","destroyPersistenceNamed","KeyList","i","l","localStorage","length","Key","key","startsWith","push","forEach","removeItem","_this2","PrefixLength","StorageKeys","_StorageKeys","_reportProgress","UpdateIndex","parseInt","slice","Update","Uint8Array","JSON","parse","getItem","Y","applyUpdate","Origin","setItem","stringify","Array","from","encodeStateAsUpdate","minimalIndex","lastFailure","console","warn","_removeStoredSubDoc","SubDoc","_StorageSubKeys","_StorageSubKeysFor","_breakdown","Provider","Message","Reason","Error","Changes","_this3","removed","loaded","get","guid","getSubdocs","values","every","existingSubDoc","has","SubDocProvider","set","providePersistenceFor","DocPrefix","Result","test","Observable"],"mappings":"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"}